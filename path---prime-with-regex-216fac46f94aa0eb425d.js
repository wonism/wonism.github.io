(window.webpackJsonp=window.webpackJsonp||[]).push([[148],{379:function(s){s.exports={data:{markdownRemark:{id:"/Users/wonism/project/wonism.github.io-gatsby/src/pages/2017-10-28-prime-with-regex/index.md absPath of file >>> MarkdownRemark",html:'<p>보통 <code class="hljs-text">소수</code>를 찾는 방법이라 하면, <code class="hljs-text">에라토네스의 체(Sieve of Eratosthenes)</code>가 떠오를 것이다.<br />\n하지만, <code class="hljs-text">정규식</code>을 이용해 단 몇 줄만으로 <code class="hljs-text">소수</code>를 찾는 방법이 있다.</p>\n<p>코드는 아래와 같다.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs-js"><code class="hljs-js"><span class="token keyword">const</span> <span class="token function-variable function">isPrime</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token regex">/^,?$|^(,,+?)\\1+$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token operator">++</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n<span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false</span>\n<span class="token function">isPrime</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n</code></pre>\n      </div>\n<p><code class="hljs-text">isPrime</code>함수는 양의 정수 <code class="hljs-text">x</code>를 인자로 받고, <code class="hljs-text">x</code>에 <code class="hljs-text">1</code> 을 더한 크기의 배열을 만든다.<br />\n여기서, <code class="hljs-text">RegExp.prototype.test</code>는 스트링을 인자로 받기 때문에 <code class="hljs-text">Array(++x)</code>는 <code class="hljs-text">x</code>개의 <code class="hljs-text">,</code>로 이루어진 문자열로 형변환된다.</p>\n<p>즉, <code class="hljs-text">x</code>만큼의 <code class="hljs-text">,</code>가 만들어진다.</p>\n<p>그리고, <code class="hljs-text">/^,?$/</code>와 <code class="hljs-text">/^(,,+?)/</code>는 <code class="hljs-text">x</code>개의 <code class="hljs-text">,</code> 로 이루어진 문자열에 대해 정규표현식 검색을 수행한다.</p>\n<p>먼저, 미리 알아두면 좋은 표현식 몇 가지를 설명하고 예시를 들어 코드를 설명하겠다.</p>\n<p>정규표현식에서</p>\n<ul>\n<li><code class="hljs-text">^X</code>는 <code class="hljs-text">X</code>로 시작하는 문자열이며, <code class="hljs-text">X$</code>는 <code class="hljs-text">X</code>로 끝나는 문자열이다.</li>\n<li><code class="hljs-text">(X)?</code>는 <code class="hljs-text">X</code> 또는 없음을 뜻한다.</li>\n<li><code class="hljs-text">(X)+</code>는 <code class="hljs-text">X</code>가 <code class="hljs-text">1</code>번 이상 반복되는 문자열이다.</li>\n<li><code class="hljs-text">(X)\\1</code>는 정규식 안 <code class="hljs-text">1</code>번째 괄호의 최근 일치 부분에 대한 역참조이다.</li>\n</ul>\n<p>만약 <code class="hljs-text">x</code>가 <code class="hljs-text">5</code>라고 하자.  그럼, <code class="hljs-text">RegExp.prototype.test</code>의 인자는 <code class="hljs-text">,,,,</code>가 된다.<br />\n<code class="hljs-text">(,,+?)</code>는 <code class="hljs-text">,,,,,</code> 의 첫 두 <code class="hljs-text">,,</code>와 매칭된다. 그리고, 역참조 <code class="hljs-text">\\1</code>은 <code class="hljs-text">,,</code> 이 되며, 전체 정규식은 <code class="hljs-text">/^,,(,,)+$/</code> 이 된다.</p>\n<p><code class="hljs-text">,,,,,</code>은 <code class="hljs-text">/^,,(,,)+$/</code> 와 매칭되지 않는다.\n<code class="hljs-text">(,,+?)</code>에서 <code class="hljs-text">+?</code> 이 사용되었기 때문에 <code class="hljs-text">,,,</code> 와 매칭을 한다.</p>\n<p><code class="hljs-text">(,,+?)</code>는 <code class="hljs-text">,,,,,</code> 의 첫 세 <code class="hljs-text">,,,</code> 와 매칭되며, <code class="hljs-text">\\1</code>는 <code class="hljs-text">,,,</code> 이 되어 정규식은 <code class="hljs-text">/^,,,(,,,)+$/</code>이 된다.</p>\n<p>매칭은 또 실패하며, <code class="hljs-text">,,,,</code>와 <code class="hljs-text">,,,,,</code>도 마찬가지이다.<br />\n따라서 <code class="hljs-text">5</code>는 <code class="hljs-text">소수</code>라는 것을 알 수 있다.</p>\n<p>이 정규식은 1998 년 <a href="https://github.com/Abigail">Abigail</a> 에 의해 처음으로 구현되었다.</p>',frontmatter:{title:"정규식으로 소수 찾기",path:"/prime-with-regex/",images:["images/js.jpg"],category:"Regular Expression",tags:["javascript","perl","regular expression","regexp","prime number"],date:"2017-10-28T00:46:32.000Z",components:null,tweets:null,summary:"보통 소수를 찾는 방법이라 하면, 에라토네스의 체(Sieve of Eratosthenes) 가 떠오를 것이다.  하지만, 정규식을 이용해, 몇 줄만으로 소수를 찾는 방법이 있다."}}},pageContext:{}}}}]);
//# sourceMappingURL=path---prime-with-regex-216fac46f94aa0eb425d.js.map